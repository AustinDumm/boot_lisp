(define (zip . lists)
    (apply map list lists))

(define (map f elts . elts*)
    (if (empty? elts)
        '()
        (cons (apply f (first elts) (map first elts*))
              (apply map f (rest elts) (map rest elts*)))))

(define (reduce f elts)
    (define (reduce-impl f running elts)
        (if (empty? elts)
            running
            (reduce-impl f (f running (first elts)) (rest elts))))
    (reduce-impl f (first elts) (rest elts)))

(define (pick index items)
    (if (= index 0)
        (first items)
        (if (empty? (rest items))
            (void)
            (pick (- index 1) (rest items)))))

(define-macro cond
    (lambda cond-list
        (let* ((cond-item (first cond-list))
               (cond-rest (rest cond-list))
               (if-condition (pick 0 cond-item))
               (is-else (eq? if-condition 'else))
               (is-last (empty? cond-rest))
               (if-condition (if is-else
                                 #t
                                 if-condition))
               (if-true (pick 1 cond-item))
               (if-false (if (or is-else is-last)
                             (void)
                             `(cond ,@cond-rest))))
            `(if ,if-condition
                 ,if-true
                 ,if-false))))
            

